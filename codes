the test code
````
// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.20;

import "forge-std/Test.sol";

import "../src/mocks/MockERC20.sol";
import "../src/mocks/MockIBT.sol";
import "../script/00_deployAccessManager.s.sol";
import "../script/01_deployRegistry.s.sol";
import "../script/02_deployPrincipalTokenInstance.s.sol";
import "../script/03_deployYTInstance.s.sol";
import "../script/04_deployPrincipalTokenBeacon.s.sol";
import "../script/05_deployYTBeacon.s.sol";
import "../script/06_deployFactory.s.sol";
import "../script/07_deployPrincipalToken.s.sol";
import "../script/08_deployCurvePool.s.sol";
import "../src/libraries/Roles.sol";
import "../src/libraries/RayMath.sol";
import "openzeppelin-contracts/proxy/beacon/UpgradeableBeacon.sol";

contract ContractFactory is Test {
    using Math for uint256;
    using RayMath for uint256;

    struct TestData {
        address erc20LP;
        uint256 mock1LPT;
        uint256 totalAssetValue;
        uint256 tokenFee;
        uint256 mock1LPT2;
        uint256 totalAssetValue2;
        uint256 mock1LPT3;
        uint256 totalAssetValue3;
        uint256 mock1LPT4;
        uint256 totalAssetValue4;
        uint256 ibtBalanceBefore;
        uint256 ibtBalanceAfter1;
        uint256 ibtBalanceAfter2;
        uint256 initialLiquidityInIBT;
        uint256 minPTShares;
        uint256 ibtBalanceInPTFromInitPrice;
        uint256 ptBalanceAdded;
        uint256 ibtBalanceAdded;
        uint256 ibtBalanceInPTFromInitPrice2;
        uint256 ptBalanceAdded2;
        uint256 ibtBalanceAdded2;
    }

    Factory public factory;
    AccessManager public accessManager;
    PrincipalToken public principalToken;
    MockERC20 public underlying;
    PrincipalToken public principalTokenInstance;
    MockIBT public ibt;
    uint256 public DURATION = 100000;
    uint256 public IBT_UNIT;
    Registry public registry;
    address public admin;
    address public scriptAdmin;
    address public curveFactoryAddress;
    address public curvePoolAddr;
    IERC20Metadata public lpToken;
    address feeCollector = 0x0000000000000000000000000000000000000FEE;
    address MOCK_ADDR_1 = 0x0000000000000000000000000000000000000001;
    uint256 public TOKENIZATION_FEE = 1e15;
    uint256 public YIELD_FEE = 0;
    uint256 public PT_FLASH_LOAN_FEE = 0;
    uint256 constant FEE_DIVISOR = 1e18;
    string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");
    uint256 fork;
    YieldToken public yt;
    UpgradeableBeacon public principalTokenBeacon;
    UpgradeableBeacon public ytBeacon;

    // Events
    event PTDeployed(address indexed principalToken, address indexed poolCreator);
    event CurvePoolDeployed(address indexed poolAddress, address indexed ibt, address indexed pt);
    event CurveFactoryChange(address indexed previousFactory, address indexed newFactory);

    error FailedToAddInitialLiquidity();

    /**
     * @dev This function is called before each test.
     */
    function setUp() public {
        fork = vm.createFork(MAINNET_RPC_URL);
        vm.selectFork(fork);
        curveFactoryAddress = 0x98EE851a00abeE0d95D08cF4CA2BdCE32aeaAF7F;
        admin = address(this); // also set as principalTokenAdmin.
        // default account for deploying scripts contracts. refer to line 35 of
        // https://github.com/foundry-rs/foundry/blob/master/evm/src/lib.rs for more details
        scriptAdmin = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
        AccessManagerDeploymentScript accessManagerScript = new AccessManagerDeploymentScript();
        accessManager = AccessManager(accessManagerScript.deployForTest(scriptAdmin));
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.UPGRADE_ROLE, scriptAdmin, 0);
        RegistryScript registryScript = new RegistryScript();
        registry = Registry(
            registryScript.deployForTest(
                TOKENIZATION_FEE,
                YIELD_FEE,
                PT_FLASH_LOAN_FEE,
                feeCollector,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, scriptAdmin, 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.FEE_SETTER_ROLE, scriptAdmin, 0);
        underlying = new MockERC20();
        underlying.initialize("MOCK UNDERLYING", "MUDL"); // deploys underlying mints 100000e18 token to caller
        ibt = new MockIBT();
        ibt.initialize("MOCK IBT", "MIBT", IERC20Metadata(address(underlying))); // deploys ibt which principalToken holds
        IBT_UNIT = 10 ** ibt.decimals();
        underlying.mint(address(this), 1);
        underlying.approve(address(ibt), 1);
        ibt.deposit(1, address(this));
        PrincipalTokenInstanceScript principalTokenInstanceScript = new PrincipalTokenInstanceScript();
        YTInstanceScript ytInstanceScript = new YTInstanceScript();
        principalTokenInstance = PrincipalToken(
            principalTokenInstanceScript.deployForTest(address(registry))
        );
        YieldToken ytInstance = YieldToken(ytInstanceScript.deployForTest());
        PrincipalTokenBeaconScript principalTokenBeaconScript = new PrincipalTokenBeaconScript();
        YTBeaconScript ytBeaconScript = new YTBeaconScript();
        principalTokenBeacon = UpgradeableBeacon(
            principalTokenBeaconScript.deployForTest(
                address(principalTokenInstance),
                address(registry),
                address(accessManager)
            )
        );
        ytBeacon = UpgradeableBeacon(
            ytBeaconScript.deployForTest(
                address(ytInstance),
                address(registry),
                address(accessManager)
            )
        );
    }

    function testDeployFactoryFailWhenRegistryIsZero() public {
        // Factory
        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("AddressError()")));
        vm.expectRevert(revertData);
        new Factory(address(0));
    }

    function testDeployFactoryFailWhenCurveAddressIsZero() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("AddressError()")));
        new Factory(address(registry));
        vm.expectRevert(revertData);
        factory = Factory(
            factoryScript.deployForTest(address(registry), address(0), address(accessManager))
        );
    }

    function testDeployPrincipalToken() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        PrincipalTokenScript principalTokenScript = new PrincipalTokenScript();
        vm.expectEmit(false, true, false, true);
        emit PTDeployed(address(principalTokenInstance), scriptAdmin);
        // deploys principalToken
        address principalTokenAddress = principalTokenScript.deployForTest(
            address(factory),
            address(ibt),
            DURATION
        );

        assertTrue(
            PrincipalToken(principalTokenAddress).maturity() == DURATION + block.timestamp,
            "PrincipalTokenFactory: Future Vault attributes do not match after deploying"
        );
    }

    function testSetCurveFactory() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );

        vm.expectEmit(true, true, false, false);
        emit CurveFactoryChange(curveFactoryAddress, address(0xfac));
        vm.prank(scriptAdmin);
        factory.setCurveFactory(address(0xfac));
    }

    function testDeployPrincipalTokenFailWithoutYTBeacon() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        RegistryScript registryScript = new RegistryScript();
        // Setup a registry with beacon proxies not set
        Registry registry2 = Registry(
            registryScript.deployForTest(
                TOKENIZATION_FEE,
                YIELD_FEE,
                PT_FLASH_LOAN_FEE,
                feeCollector,
                address(accessManager)
            )
        );
        factory = Factory(
            factoryScript.deployForTest(
                address(registry2),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);
        bytes memory revertData = abi.encodeWithSignature("BeaconNotSet()");
        vm.expectRevert(revertData);
        factory.deployPT(address(ibt), DURATION);
    }

    function testDeployPrincipalTokenWithBeaconNotSet() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        RegistryScript registryScript = new RegistryScript();
        // Setup a registry with beacon proxies not set
        Registry registry2 = Registry(
            registryScript.deployForTest(
                TOKENIZATION_FEE,
                YIELD_FEE,
                PT_FLASH_LOAN_FEE,
                feeCollector,
                address(accessManager)
            )
        );
        factory = Factory(
            factoryScript.deployForTest(
                address(registry2),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("BeaconNotSet()")));
        vm.expectRevert(revertData);
        factory.deployPT(address(ibt), DURATION);
    }

    function testFactoryDeployCurvePoolWithUnregisteredPTFail() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("UnregisteredPT()")));
        vm.expectRevert(revertData);
        factory.deployCurvePool(
            address(0),
            IFactory.CurvePoolParams(0, 0, 0, 0, 0, 0, 0, 0, 0),
            0,
            0
        );
    }

    function testFactoryDeployCurvePoolWithExpiredPTFail() public {
        // Factory
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );

        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        // deploy principalToken
        PrincipalTokenScript principalTokenScript = new PrincipalTokenScript();
        address principalTokenAddress = principalTokenScript.deployForTest(
            address(factory),
            address(ibt),
            DURATION
        );
        principalToken = PrincipalToken(principalTokenAddress);

        _increaseTimeToExpiry();

        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("ExpiredPT()")));
        vm.expectRevert(revertData);
        factory.deployCurvePool(
            principalTokenAddress,
            IFactory.CurvePoolParams(0, 0, 0, 0, 0, 0, 0, 0, 0),
            0,
            0
        );
    }

    function testFactoryDeployCurvePoolWithTooBigMinPTSharesFail() public {
        TestData memory data;

        // Factory
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );

        vm.startPrank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);
        vm.stopPrank();

        // deploy principalToken
        PrincipalTokenScript principalTokenScript = new PrincipalTokenScript();
        address principalTokenAddress = principalTokenScript.deployForTest(
            address(factory),
            address(ibt),
            DURATION
        );
        principalToken = PrincipalToken(principalTokenAddress);

        uint256 initialPrice = 8e17;

        IFactory.CurvePoolParams memory curvePoolParams = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: initialPrice
        });

        data.initialLiquidityInIBT = 100 * IBT_UNIT;

        // compute minPTShares for given initialLiquidityInIBT
        {
            // fictive balances of pool to be deployed
            uint256 poolPTBalance = 10 ** IERC20Metadata(ibt).decimals();
            uint256 poolIBTBalance = poolPTBalance.mulDiv(initialPrice, CurvePoolUtil.CURVE_UNIT);
            // compute the worth of the fictive IBT balance in the pool in PT
            uint256 poolIBTBalanceInPT = principalToken.previewDepositIBT(poolIBTBalance);

            // compute the portion of IBT to deposit in PT
            uint256 ibtsToTokenize = data.initialLiquidityInIBT.mulDiv(
                poolPTBalance,
                poolIBTBalanceInPT + poolPTBalance
            );

            data.minPTShares = principalToken.previewDepositIBT(ibtsToTokenize);
        }

        // mint IBT to user
        underlying.mint(MOCK_ADDR_1, ibt.convertToAssets(100 * IBT_UNIT));
        vm.startPrank(MOCK_ADDR_1);
        underlying.approve(address(ibt), ibt.convertToAssets(100 * IBT_UNIT));
        ibt.mint(data.initialLiquidityInIBT, MOCK_ADDR_1);
        ibt.approve(address(factory), data.initialLiquidityInIBT);

        bytes memory revertData = abi.encodeWithSelector(
            bytes4(keccak256("ERC5143SlippageProtectionFailed()"))
        );
        vm.expectRevert(revertData);
        // deployment + addLiquidity should revert with minPTShares too big
        IFactory(factory).deployCurvePool(
            address(principalToken),
            curvePoolParams,
            data.initialLiquidityInIBT,
            data.minPTShares + 1
        );

        // deployment + addLiquidity should not revert
        IFactory(factory).deployCurvePool(
            address(principalToken),
            curvePoolParams,
            data.initialLiquidityInIBT,
            data.minPTShares
        );

        vm.stopPrank();
    }

    function testFactoryDeployAllWithoutInitialLiquidity() public {
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        IFactory.CurvePoolParams memory curvePoolParams = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: 1e18
        });

        (address pt, address curvePool) = IFactory(factory).deployAll(
            address(ibt),
            DURATION,
            curvePoolParams,
            0,
            0
        );
        assertEq(IPrincipalToken(pt).underlying(), ibt.asset());
        assertEq(IPrincipalToken(pt).getDuration(), DURATION);
        assertEq(IPrincipalToken(pt).getIBT(), address(ibt));
        assertEq(ICurveNGPool(curvePool).symbol(), "SPT-PT/IBT");
        assertEq(ICurveNGPool(curvePool).name(), "Spectra-PT/IBT");

        assertEq(
            IPrincipalToken(pt).symbol(),
            NamingUtil.genPTSymbol(ibt.symbol(), IPrincipalToken(pt).maturity())
        );
        assertEq(
            IPrincipalToken(pt).name(),
            NamingUtil.genPTName(ibt.symbol(), IPrincipalToken(pt).maturity())
        );

        assertEq(ICurveNGPool(curvePool).A(), curvePoolParams.A);
        assertEq(ICurveNGPool(curvePool).gamma(), curvePoolParams.gamma);
        assertEq(ICurveNGPool(curvePool).mid_fee(), curvePoolParams.mid_fee);
        assertEq(ICurveNGPool(curvePool).out_fee(), curvePoolParams.out_fee);
        assertEq(ICurveNGPool(curvePool).fee_gamma(), curvePoolParams.fee_gamma);
        assertEq(
            ICurveNGPool(curvePool).allowed_extra_profit(),
            curvePoolParams.allowed_extra_profit
        );
        assertEq(ICurveNGPool(curvePool).adjustment_step(), curvePoolParams.adjustment_step);
        assertEq(ICurveNGPool(curvePool).ma_time(), (curvePoolParams.ma_exp_time * 694) / 1000); // To get time in seconds, the parameter is multipled by ln(2)
    }

    function testFactoryDeployAllWithInitialLiquidityFuzz(
        uint256 amount,
        uint256 initialPrice,
        uint16 changeRate,
        bool increaseRate
    ) public {
        TestData memory data;
        amount = bound(amount, IBT_UNIT / 1000, 1_000_000_000_000_000 * IBT_UNIT);
        initialPrice = bound(initialPrice, 1e15, 1e20);
        int256 _changeRate = int256(bound(changeRate, 0, 10000));
        if (!increaseRate) {
            if (_changeRate > 99) {
                _changeRate = 99;
            }
        }
        _increaseRate(_changeRate);
        FactoryScript factoryScript = new FactoryScript();
        factory = Factory(
            factoryScript.deployForTest(
                address(registry),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        IFactory.CurvePoolParams memory curvePoolParams = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: initialPrice
        });

        data.initialLiquidityInIBT = amount;

        {
            uint256 poolPTBalance = 10 ** IERC20Metadata(ibt).decimals();
            uint256 poolIBTBalance = poolPTBalance.mulDiv(initialPrice, CurvePoolUtil.CURVE_UNIT);
            uint256 currentIBTRate = ibt.previewRedeem(IBT_UNIT).toRay(underlying.decimals());

            // convert the worth of the fictive IBT balance in the pool to (not yet deployed) PT
            poolIBTBalance -= poolIBTBalance.mulDiv(
                TOKENIZATION_FEE,
                FEE_DIVISOR,
                Math.Rounding.Ceil
            );
            uint256 poolIBTBalanceInPT = poolIBTBalance.mulDiv(currentIBTRate, RayMath.RAY_UNIT);

            // compute the portion of IBT to deposit in PT
            uint256 ibtsToTokenize = data.initialLiquidityInIBT.mulDiv(
                poolPTBalance,
                poolIBTBalanceInPT + poolPTBalance
            );

            // convert the portion of IBT to (not yet deployed) PT
            ibtsToTokenize -= ibtsToTokenize.mulDiv(
                TOKENIZATION_FEE,
                FEE_DIVISOR,
                Math.Rounding.Ceil
            );
            data.minPTShares = ibtsToTokenize.mulDiv(currentIBTRate, RayMath.RAY_UNIT);
        }

        underlying.mint(MOCK_ADDR_1, 3 * ibt.convertToAssets(amount));
        vm.startPrank(MOCK_ADDR_1);
        underlying.approve(address(ibt), 3 * ibt.convertToAssets(amount));
        ibt.deposit(3 * ibt.convertToAssets(amount), MOCK_ADDR_1);
        vm.stopPrank();

        data.ibtBalanceBefore = IERC4626(ibt).balanceOf(MOCK_ADDR_1);

        // testing factory's deploy all
        vm.startPrank(MOCK_ADDR_1);
        ibt.approve(address(factory), amount);
        (address pt, address curvePool) = IFactory(factory).deployAll(
            address(ibt),
            DURATION,
            curvePoolParams,
            data.initialLiquidityInIBT,
            data.minPTShares
        );
        vm.stopPrank();

        data.ibtBalanceAfter1 = IERC4626(ibt).balanceOf(MOCK_ADDR_1);

        assertEq(IPrincipalToken(pt).underlying(), ibt.asset());
        assertEq(IPrincipalToken(pt).getDuration(), DURATION);
        assertEq(IPrincipalToken(pt).getIBT(), address(ibt));
        assertEq(ICurveNGPool(curvePool).symbol(), "SPT-PT/IBT");
        assertEq(ICurveNGPool(curvePool).name(), "Spectra-PT/IBT");

        assertEq(
            IPrincipalToken(pt).symbol(),
            NamingUtil.genPTSymbol(ibt.symbol(), IPrincipalToken(pt).maturity())
        );
        assertEq(
            IPrincipalToken(pt).name(),
            NamingUtil.genPTName(ibt.symbol(), IPrincipalToken(pt).maturity())
        );

        assertEq(ICurveNGPool(curvePool).A(), curvePoolParams.A);
        assertEq(ICurveNGPool(curvePool).gamma(), curvePoolParams.gamma);
        assertEq(ICurveNGPool(curvePool).mid_fee(), curvePoolParams.mid_fee);
        assertEq(ICurveNGPool(curvePool).out_fee(), curvePoolParams.out_fee);
        assertEq(ICurveNGPool(curvePool).fee_gamma(), curvePoolParams.fee_gamma);
        assertEq(
            ICurveNGPool(curvePool).allowed_extra_profit(),
            curvePoolParams.allowed_extra_profit
        );
        assertEq(ICurveNGPool(curvePool).adjustment_step(), curvePoolParams.adjustment_step);
        assertEq(ICurveNGPool(curvePool).ma_time(), (curvePoolParams.ma_exp_time * 694) / 1000); // To get time in seconds, the parameter is multipled by ln(2)
        assertEq(ICurveNGPool(curvePool).coins(0), address(ibt), "Curve pool has wrong coin 0");
        assertEq(ICurveNGPool(curvePool).coins(1), pt, "Curve pool has wrong coin 1");
        if (initialPrice > 1e18) {
            assertApproxGeAbs(
                ICurveNGPool(curvePool).balances(0),
                ICurveNGPool(curvePool).balances(1),
                10
            );
        } else {
            assertApproxGeAbs(
                ICurveNGPool(curvePool).balances(1),
                ICurveNGPool(curvePool).balances(0),
                10
            );
        }
        data.ibtBalanceInPTFromInitPrice = IPrincipalToken(pt).previewDepositIBT(
            (IBT_UNIT).mulDiv(initialPrice, 1e18)
        );
        data.ptBalanceAdded = data.initialLiquidityInIBT.mulDiv(
            IBT_UNIT,
            IBT_UNIT + data.ibtBalanceInPTFromInitPrice
        ); // in IBT for now
        data.ibtBalanceAdded = data.initialLiquidityInIBT - data.ptBalanceAdded;
        data.ptBalanceAdded = IPrincipalToken(pt).previewDepositIBT(data.ptBalanceAdded);
        assertApproxEqAbs(
            ICurveNGPool(curvePool).balances(0),
            data.ibtBalanceAdded,
            100,
            "IBT balance of curve pool is wrong"
        );
        assertApproxEqAbs(
            ICurveNGPool(curvePool).balances(1),
            data.ptBalanceAdded,
            100,
            "PT balance of curve pool is wrong"
        );
        assertEq(
            data.ibtBalanceBefore,
            data.ibtBalanceAfter1 + data.initialLiquidityInIBT,
            "IBT balance of user is wrong"
        );

        {
            uint256 poolPTBalance = 10 ** IERC20Metadata(ibt).decimals();
            uint256 poolIBTBalance = poolPTBalance.mulDiv(initialPrice, CurvePoolUtil.CURVE_UNIT);
            // convert the worth of the fictive IBT balance in the pool to PT
            uint256 poolIBTBalanceInPT = IPrincipalToken(pt).previewDepositIBT(poolIBTBalance);

            // compute the portion of IBT to deposit in PT
            uint256 ibtsToTokenize = data.initialLiquidityInIBT.mulDiv(
                poolPTBalance,
                poolIBTBalanceInPT + poolPTBalance
            );

            data.minPTShares = IPrincipalToken(pt).previewDepositIBT(ibtsToTokenize);
        }

        // testing factory's deploy curve pool
        vm.startPrank(MOCK_ADDR_1);
        ibt.approve(address(factory), amount);
        address curvePool2 = IFactory(factory).deployCurvePool(
            pt,
            curvePoolParams,
            data.initialLiquidityInIBT,
            data.minPTShares
        );
        vm.stopPrank();

        data.ibtBalanceAfter2 = IERC4626(ibt).balanceOf(MOCK_ADDR_1);

        assertEq(ICurveNGPool(curvePool2).symbol(), "SPT-PT/IBT");
        assertEq(ICurveNGPool(curvePool2).name(), "Spectra-PT/IBT");
        assertEq(ICurveNGPool(curvePool2).A(), curvePoolParams.A);
        assertEq(ICurveNGPool(curvePool2).gamma(), curvePoolParams.gamma);
        assertEq(ICurveNGPool(curvePool2).mid_fee(), curvePoolParams.mid_fee);
        assertEq(ICurveNGPool(curvePool2).out_fee(), curvePoolParams.out_fee);
        assertEq(ICurveNGPool(curvePool2).fee_gamma(), curvePoolParams.fee_gamma);
        assertEq(
            ICurveNGPool(curvePool2).allowed_extra_profit(),
            curvePoolParams.allowed_extra_profit
        );
        assertEq(ICurveNGPool(curvePool2).adjustment_step(), curvePoolParams.adjustment_step);
        assertEq(ICurveNGPool(curvePool2).ma_time(), (curvePoolParams.ma_exp_time * 694) / 1000); // To get time in seconds, the parameter is multipled by ln(2)
        assertEq(ICurveNGPool(curvePool2).coins(0), address(ibt), "Curve pool has wrong coin 0");
        assertEq(ICurveNGPool(curvePool2).coins(1), pt, "Curve pool has wrong coin 1");
        if (initialPrice > 1e18) {
            assertApproxGeAbs(
                ICurveNGPool(curvePool2).balances(0),
                ICurveNGPool(curvePool2).balances(1),
                10
            );
        } else {
            assertApproxGeAbs(
                ICurveNGPool(curvePool2).balances(1),
                ICurveNGPool(curvePool2).balances(0),
                10
            );
        }
        data.ibtBalanceInPTFromInitPrice2 = IPrincipalToken(pt).previewDepositIBT(
            (IBT_UNIT).mulDiv(initialPrice, 1e18)
        );
        data.ptBalanceAdded2 = data.initialLiquidityInIBT.mulDiv(
            IBT_UNIT,
            IBT_UNIT + data.ibtBalanceInPTFromInitPrice2
        ); // in IBT for now
        data.ibtBalanceAdded2 = data.initialLiquidityInIBT - data.ptBalanceAdded2;
        data.ptBalanceAdded2 = IPrincipalToken(pt).previewDepositIBT(data.ptBalanceAdded2);
        assertApproxEqAbs(
            ICurveNGPool(curvePool2).balances(0),
            data.ibtBalanceAdded2,
            100,
            "IBT balance of curve pool is wrong"
        );
        assertApproxEqAbs(
            ICurveNGPool(curvePool2).balances(1),
            data.ptBalanceAdded2,
            100,
            "PT balance of curve pool is wrong"
        );
        assertEq(
            data.ibtBalanceAfter1,
            data.ibtBalanceAfter2 + data.initialLiquidityInIBT,
            "IBT balance of user is wrong"
        );
    }

    function testFactoryDeployAllFailBeaconNotSet() public {
        FactoryScript factoryScript = new FactoryScript();
        RegistryScript registryScript = new RegistryScript();
        // Setup a registry with beacon proxies not set
        Registry registry2 = Registry(
            registryScript.deployForTest(
                TOKENIZATION_FEE,
                YIELD_FEE,
                PT_FLASH_LOAN_FEE,
                feeCollector,
                address(accessManager)
            )
        );
        factory = Factory(
            factoryScript.deployForTest(
                address(registry2),
                curveFactoryAddress,
                address(accessManager)
            )
        );
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        IFactory.CurvePoolParams memory curvePoolParams = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: 1e18
        });

        bytes memory revertData = abi.encodeWithSelector(bytes4(keccak256("BeaconNotSet()")));

        vm.expectRevert(revertData);
        IFactory(factory).deployAll(address(ibt), DURATION, curvePoolParams, 0, 0);
    }

    function _increaseTimeToExpiry() internal {
        uint256 time = block.timestamp + principalToken.maturity();
        vm.warp(time);
    }

    /**
     * @dev Internal function for changing ibt rate with a determined rate as passed
     */
    function _increaseRate(int256 rate) internal {
        int256 currentRate = int256(ibt.convertToAssets(10 ** ibt.decimals()));
        int256 newRate = (currentRate * (rate + 100)) / 100;
        ibt.setPricePerFullShare(uint256(newRate));
    }

    function assertApproxGeAbs(uint a, uint b, uint maxDelta) internal {
        if (!(a >= b)) {
            uint dt = b - a;
            if (dt > maxDelta) {
                emit log("Error: a >=~ b not satisfied [uint]");
                emit log_named_uint("   Value a", a);
                emit log_named_uint("   Value b", b);
                emit log_named_uint(" Max Delta", maxDelta);
                emit log_named_uint("     Delta", dt);
                fail();
            }
        }
    }
}
````
the script code
````
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import "../src/factory/Factory.sol";
import "../src/proxy/AMTransparentUpgradeableProxy.sol";
import "../src/proxy/AMProxyAdmin.sol";
import "../src/libraries/Roles.sol";
import "openzeppelin-contracts/access/manager/IAccessManager.sol";

// script to deploy the Factory Instance and Proxy
contract FactoryScript is Script {
    bytes4[] private selectors_proxy_admin = new bytes4[](1);
    bytes4[] private factory_selector = new bytes4[](1);
    address private testRes;
    address private registry;
    address private curveFactoryAddress;
    address private accessManager;
    bool private forTest;

    function run() public {
        vm.startBroadcast();
        selectors_proxy_admin[0] = AMProxyAdmin(address(0)).upgradeAndCall.selector;
        factory_selector[0] = Factory(address(0)).setCurveFactory.selector;
        if (forTest) {
            address factoryInstance = address(new Factory(registry));
            console.log("Factory instance deployed at", factoryInstance);

            address FactoryProxy = address(
                new AMTransparentUpgradeableProxy(
                    factoryInstance,
                    accessManager,
                    abi.encodeWithSelector(
                        Factory(address(0)).initialize.selector,
                        accessManager,
                        curveFactoryAddress
                    )
                )
            );
            console.log("Factory proxy deployed at", FactoryProxy);
            bytes32 adminSlot = vm.load(address(FactoryProxy), ERC1967Utils.ADMIN_SLOT);
            address proxyAdmin = address(uint160(uint256(adminSlot)));
            IRegistry(registry).setFactory(FactoryProxy);
            IAccessManager(accessManager).setTargetFunctionRole(
                proxyAdmin,
                selectors_proxy_admin,
                Roles.UPGRADE_ROLE
            );
            IAccessManager(accessManager).setTargetFunctionRole(
                FactoryProxy,
                factory_selector,
                Roles.REGISTRY_ROLE
            );
            console.log("Function setTargetFunctionRole Role set for ProxyAdmin");
            testRes = FactoryProxy;
        } else {
            string memory deploymentNetwork = vm.envString("DEPLOYMENT_NETWORK");
            if (bytes(deploymentNetwork).length == 0) {
                revert("DEPLOYMENT_NETWORK is not set in .env file");
            }

            string memory envVar = string.concat("ACCESS_MANAGER_ADDRESS_", deploymentNetwork);
            if (bytes(vm.envString(envVar)).length == 0) {
                revert(string.concat(envVar, " is not set in .env file"));
            }
            accessManager = vm.envAddress(envVar);

            envVar = string.concat("REGISTRY_ADDR_", deploymentNetwork);
            if (bytes(vm.envString(envVar)).length == 0) {
                revert(string.concat(envVar, " is not set in .env file"));
            }
            registry = vm.envAddress(envVar);

            envVar = string.concat("CURVE_FACTORY_", deploymentNetwork);
            if (bytes(vm.envString(envVar)).length == 0) {
                revert(string.concat(envVar, " is not set in .env file"));
            }
            curveFactoryAddress = vm.envAddress(envVar);

            address factoryInstance = address(new Factory(registry));
            console.log("Factory instance deployed at", factoryInstance);

            address FactoryProxy = address(
                new AMTransparentUpgradeableProxy(
                    factoryInstance,
                    accessManager,
                    abi.encodeWithSelector(
                        Factory(address(0)).initialize.selector,
                        accessManager,
                        curveFactoryAddress
                    )
                )
            );
            console.log("Factory proxy deployed at", FactoryProxy);
            IRegistry(registry).setFactory(FactoryProxy);
            bytes32 adminSlot = vm.load(address(FactoryProxy), ERC1967Utils.ADMIN_SLOT);
            address proxyAdmin = address(uint160(uint256(adminSlot)));
            console.log("Factory Proxy Admin Address:", address(proxyAdmin));
            IAccessManager(accessManager).setTargetFunctionRole(
                proxyAdmin,
                selectors_proxy_admin,
                Roles.UPGRADE_ROLE
            );
            IAccessManager(accessManager).setTargetFunctionRole(
                FactoryProxy,
                factory_selector,
                Roles.REGISTRY_ROLE
            );
            console.log("Function setTargetFunctionRole Role set for ProxyAdmin");
        }
        vm.stopBroadcast();
    }

    function deployForTest(
        address _registry,
        address _curveFactoryAddress,
        address _accessManager
    ) public returns (address _testRes) {
        forTest = true;
        registry = _registry;
        curveFactoryAddress = _curveFactoryAddress;
        accessManager = _accessManager;
        run();
        forTest = false;
        _testRes = testRes;
        testRes = address(0);
        curveFactoryAddress = address(0);
        registry = address(0);
        accessManager = address(0);
    }
}

```
the contract code
```
// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.20;

import "openzeppelin-math/Math.sol";
import "openzeppelin-contracts/access/manager/IAccessManager.sol";
import "openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol";
import "openzeppelin-contracts/proxy/beacon/BeaconProxy.sol";
import "openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol";
import "../interfaces/IFactory.sol";
import "../interfaces/ICurveNGPool.sol";
import "../interfaces/ICurveNGFactory.sol";
import "../interfaces/IPrincipalToken.sol";
import "../interfaces/IRegistry.sol";
import "../libraries/CurvePoolUtil.sol";
import "../libraries/Roles.sol";

/**
 * @title PrincipalTokenUtil library
 * @author Spectra Finance
 * @notice Factory used to deploy PTs and pools.
 */
contract Factory is IFactory, AccessManagedUpgradeable {
    using SafeERC20 for IERC20;
    using Math for uint256;

    uint256 constant IMPLEMENTATION_ID = 0;

    bytes4 constant PAUSE_SELECTOR = IPrincipalToken(address(0)).pause.selector;
    bytes4 constant UNPAUSE_SELECTOR = IPrincipalToken(address(0)).unPause.selector;
    bytes4 constant SET_REWARDS_PROXY_SELECTOR =
        IPrincipalToken(address(0)).setRewardsProxy.selector;
    bytes4 constant CLAIM_REWARDS_SELECTOR = IPrincipalToken(address(0)).claimRewards.selector;

    /** @notice registry of the protocol */
    address private immutable registry;

    /* State
     *****************************************************************************************************************/

    /** @notice Factory of Curve protocol, used to deploy pools */
    address private curveFactory;

    /* Events
     *****************************************************************************************************************/

    event PTDeployed(address indexed pt, address indexed poolCreator);
    event CurvePoolDeployed(address indexed poolAddress, address indexed ibt, address indexed pt);
    event RegistryChange(address indexed previousRegistry, address indexed newRegistry);
    event CurveFactoryChange(address indexed previousFactory, address indexed newFactory);

    /**
     * @notice Constructor of the contract
     * @param _registry The address of the registry.
     */
    constructor(address _registry) {
        if (_registry == address(0)) {
            revert AddressError();
        }
        registry = _registry;
        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.
    }

    /**
     * @notice Initializer of the contract
     * @param _initialAuthority The address of the access manager.
     * @param _curveFactory The address of the Curve Factory (TwoCrypto-NG).
     */
    function initialize(address _initialAuthority, address _curveFactory) external initializer {
        __AccessManaged_init(_initialAuthority);
        _setCurveFactory(_curveFactory);
    }

    /** @dev See {IFactory-deployPT}. */
    function deployPT(address _ibt, uint256 _duration) public override returns (address pt) {
        address ptBeacon = IRegistry(registry).getPTBeacon();
        if (ptBeacon == address(0)) {
            revert BeaconNotSet();
        }

        address accessManager = authority();
        bytes memory _data = abi.encodeWithSelector(
            IPrincipalToken(address(0)).initialize.selector,
            _ibt,
            _duration,
            accessManager
        );
        pt = address(new BeaconProxy(ptBeacon, _data));
        emit PTDeployed(pt, msg.sender);
        IRegistry(registry).addPT(pt);

        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);
        IAccessManager(accessManager).setTargetFunctionRole(
            pt,
            getClaimRewardsProxySelectors(),
            Roles.REWARDS_HARVESTER_ROLE
        );
        IAccessManager(accessManager).setTargetFunctionRole(
            pt,
            getSetRewardsProxySelectors(),
            Roles.REWARDS_PROXY_SETTER_ROLE
        );
    }

    /** @dev See {IFactory-deployCurvePool}. */
    function deployCurvePool(
        address _pt,
        CurvePoolParams calldata _curvePoolParams,
        uint256 _initialLiquidityInIBT,
        uint256 _minPTShares
    ) public returns (address curvePool) {
        if (!IRegistry(registry).isRegisteredPT(_pt)) {
            revert UnregisteredPT();
        }
        if (IPrincipalToken(_pt).maturity() < block.timestamp) {
            revert ExpiredPT();
        }
        address ibt = IPrincipalToken(_pt).getIBT();
        address[2] memory coins;
        {
            coins[0] = ibt;
            coins[1] = _pt;
        }
        curvePool = _deployCurvePool(coins, _curvePoolParams);
        emit CurvePoolDeployed(curvePool, ibt, _pt);

        if (_initialLiquidityInIBT != 0) {
            _addInitialLiquidity(
                curvePool,
                _initialLiquidityInIBT,
                _minPTShares,
                _curvePoolParams.initial_price
            );
        }
    }

    /** @dev See {IFactory-deployAll}. */
    function deployAll(
        address _ibt,
        uint256 _duration,
        CurvePoolParams calldata _curvePoolParams,
        uint256 _initialLiquidityInIBT,
        uint256 _minPTShares
    ) public returns (address pt, address curvePool) {
        // deploy PT
        address ptBeacon = IRegistry(registry).getPTBeacon();
        if (ptBeacon == address(0)) {
            revert BeaconNotSet();
        }
        address accessManager = authority();
        bytes memory _encodedData = abi.encodeWithSelector(
            IPrincipalToken(address(0)).initialize.selector,
            _ibt,
            _duration,
            accessManager
        );
        pt = address(new BeaconProxy(ptBeacon, _encodedData));
        emit PTDeployed(pt, msg.sender);
        IRegistry(registry).addPT(pt);
        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);
        IAccessManager(accessManager).setTargetFunctionRole(
            pt,
            getClaimRewardsProxySelectors(),
            Roles.REWARDS_HARVESTER_ROLE
        );
        IAccessManager(accessManager).setTargetFunctionRole(
            pt,
            getSetRewardsProxySelectors(),
            Roles.REWARDS_PROXY_SETTER_ROLE
        );

        // deploy rate oracle

        // deploy Curve Pool
        address[2] memory coins;
        {
            coins[0] = _ibt;
            coins[1] = pt;
        }
        curvePool = _deployCurvePool(coins, _curvePoolParams);
        emit CurvePoolDeployed(curvePool, _ibt, pt);

        if (_initialLiquidityInIBT != 0) {
            _addInitialLiquidity(
                curvePool,
                _initialLiquidityInIBT,
                _minPTShares,
                _curvePoolParams.initial_price
            );
        }
    }

    /* GETTERS
     *****************************************************************************************************************/

    /** @dev See {IFactory-getRegistry}. */
    function getRegistry() external view override returns (address) {
        return registry;
    }

    /** @dev See {IFactory-getCurveFactory}. */
    function getCurveFactory() external view override returns (address) {
        return curveFactory;
    }

    /**
     * @notice Getter for pause and unpause selectors, used for access management
     */
    function getPauserSigs() internal pure returns (bytes4[] memory) {
        bytes4[] memory selectors = new bytes4[](2);
        selectors[0] = PAUSE_SELECTOR;
        selectors[1] = UNPAUSE_SELECTOR;
        return selectors;
    }

    /**
     * @notice Getter for the reward proxy setter selector, used for access management
     */
    function getSetRewardsProxySelectors() internal pure returns (bytes4[] memory) {
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = SET_REWARDS_PROXY_SELECTOR;
        return selectors;
    }

    /**
     * @notice Getter for the claim rewards selector, used for access management
     */
    function getClaimRewardsProxySelectors() internal pure returns (bytes4[] memory) {
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = CLAIM_REWARDS_SELECTOR;
        return selectors;
    }

    /* SETTERS
     *****************************************************************************************************************/

    /** @dev See {IFactory-setCurveFactory}. */
    function setCurveFactory(address _curveFactory) public override restricted {
        _setCurveFactory(_curveFactory);
    }

    /**
     * @dev Splits the given IBT amount into IBT and PT based on pool initial price, and adds liquidity to the pool.
     * @param _curvePool The address of the Curve Pool in which the user adds initial liquidity to
     * @param _initialLiquidityInIBT The initial liquidity to seed the Curve Pool with (in IBT)
     * @param _minPTShares The minimum allowed shares from deposit in PT
     * @param _initialPrice The initial price of the Curve Pool
     */
    function _addInitialLiquidity(
        address _curvePool,
        uint256 _initialLiquidityInIBT,
        uint256 _minPTShares,
        uint256 _initialPrice
    ) internal {
        address ibt = ICurveNGPool(_curvePool).coins(0);
        address pt = ICurveNGPool(_curvePool).coins(1);

        {
            // support for fee-on-transfer tokens
            uint256 balBefore = IERC20(ibt).balanceOf(address(this));
            IERC20(ibt).safeTransferFrom(msg.sender, address(this), _initialLiquidityInIBT);
            _initialLiquidityInIBT = IERC20(ibt).balanceOf(address(this)) - balBefore;
        }

        // using fictive pool balances, the user is adding liquidity in a ratio that (closely) matches the empty pool's initial price
        // with ptBalance = IBT_UNIT for having a fictive PT balance reference, ibtBalance = IBT_UNIT x initialPrice
        uint256 ptBalance = 10 ** IERC20Metadata(ibt).decimals();
        uint256 ibtBalance = ptBalance.mulDiv(_initialPrice, CurvePoolUtil.CURVE_UNIT);
        // compute the worth of the fictive IBT balance in the pool in PT
        uint256 ibtBalanceInPT = IPrincipalToken(pt).previewDepositIBT(ibtBalance);
        // compute the portion of IBT to deposit in PT
        uint256 ibtsToTokenize = _initialLiquidityInIBT.mulDiv(
            ptBalance,
            ibtBalanceInPT + ptBalance
        );

        // IBT amount to deposit in the Curve Pool
        uint256 amount0 = _initialLiquidityInIBT - ibtsToTokenize;
        uint256 allowancePT = IERC20(ibt).allowance(address(this), pt);
        if (allowancePT < ibtsToTokenize) {
            IERC20(ibt).forceApprove(pt, type(uint256).max);
        }
        // PT amount to deposit in Curve Pool
        uint256 amount1 = IPrincipalToken(pt).depositIBT(
            ibtsToTokenize,
            address(this),
            msg.sender,
            _minPTShares
        );

        IERC20(ibt).safeIncreaseAllowance(_curvePool, amount0);
        IERC20(pt).safeIncreaseAllowance(_curvePool, amount1);
        ICurveNGPool(_curvePool).add_liquidity([amount0, amount1], 0);
    }

    /**
     * @dev Calls the Curve factory and deploys a new Curve v2 crypto pool
     */
    function _deployCurvePool(
        address[2] memory _coins,
        CurvePoolParams calldata _p
    ) internal returns (address curvePoolAddr) {
        if (curveFactory == address(0)) {
            revert CurveFactoryNotSet();
        }
        bytes memory name = bytes("Spectra-PT/IBT");
        bytes memory symbol = bytes("SPT-PT/IBT");
        bytes memory cd = new bytes(576); // calldata to the curve factory
        address coin0 = _coins[0];
        address coin1 = _coins[1];
        uint256 num; // temporary variable for passing contents of _p to Yul
        // append the coins array
        assembly {
            mstore(
                add(cd, 0x20),
                0x00000000000000000000000000000000000000000000000000000000000001c0
            )
            mstore(
                add(cd, 0x40),
                0x0000000000000000000000000000000000000000000000000000000000000200
            )
            mstore(add(cd, 0x60), coin0)
            mstore(add(cd, 0x80), coin1)
        }

        // append the numerical parameters
        num = IMPLEMENTATION_ID; // implementation_id
        assembly {
            mstore(add(cd, 0xa0), num)
        }
        num = _p.A;
        assembly {
            mstore(add(cd, 0xc0), num)
        }
        num = _p.gamma;
        assembly {
            mstore(add(cd, 0xe0), num)
        }
        num = _p.mid_fee;
        assembly {
            mstore(add(cd, 0x100), num)
        }
        num = _p.out_fee;
        assembly {
            mstore(add(cd, 0x120), num)
        }
        num = _p.fee_gamma;
        assembly {
            mstore(add(cd, 0x140), num)
        }
        num = _p.allowed_extra_profit;
        assembly {
            mstore(add(cd, 0x160), num)
        }
        num = _p.adjustment_step;
        assembly {
            mstore(add(cd, 0x180), num)
        }
        num = _p.ma_exp_time;
        assembly {
            mstore(add(cd, 0x1a0), num)
        }
        num = _p.initial_price;

        assembly {
            mstore(add(cd, 0x1c0), num)

            mstore(add(cd, 0x1e0), mload(name))
            mstore(add(cd, 0x200), mload(add(name, 0x20)))

            mstore(add(cd, 0x220), mload(symbol))
            mstore(add(cd, 0x240), mload(add(symbol, 0x20)))
        }

        // prepend the function selector
        cd = bytes.concat(ICurveNGFactory(address(0)).deploy_pool.selector, cd);

        // make the call to the curve factory
        (bool success, bytes memory result) = address(curveFactory).call(cd);
        if (!success) {
            revert DeploymentFailed();
        }

        assembly {
            curvePoolAddr := mload(add(add(result, 12), 20))
        }
    }

    function _setCurveFactory(address _curveFactory) internal {
        if (_curveFactory == address(0)) {
            revert AddressError();
        }
        emit CurveFactoryChange(curveFactory, _curveFactory);
        curveFactory = _curveFactory;
    }
}

````

test code that is not working
````
 function testUnnecessaryAllowanceWastesGas() public {
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        address ptAddr = factory.deployPT(address(ibt), DURATION);

        IFactory.CurvePoolParams memory params = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: 1e18
        });

        uint256 initialLiquidity = 100 * IBT_UNIT;
        underlying.mint(MOCK_ADDR_1, ibt.convertToAssets(initialLiquidity));
        vm.startPrank(MOCK_ADDR_1);
        underlying.approve(address(ibt), ibt.convertToAssets(initialLiquidity));
        ibt.deposit(ibt.convertToAssets(initialLiquidity), MOCK_ADDR_1);
        ibt.approve(address(factory), initialLiquidity);

        address curvePool = factory.deployCurvePool(ptAddr, params, initialLiquidity, 0);
        ibt.approve(curvePool, initialLiquidity); // Pre-approve
        uint256 gasBefore = gasleft();
        factory.deployCurvePool(ptAddr, params, initialLiquidity, 0);
        uint256 gasUsed = gasBefore - gasleft();
        assertGt(gasUsed, 50000, "Extra gas not consumed");
        vm.stopPrank();
    }

    function testZeroPTBreaksPool() public {
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.ADMIN_ROLE, address(factory), 0);
        vm.prank(scriptAdmin);
        accessManager.grantRole(Roles.REGISTRY_ROLE, address(factory), 0);

        address ptAddr = factory.deployPT(address(ibt), DURATION);
        vm.makePersistent(ptAddr);
        //assertTrue(ptAddr != address(0), "PT deployment failed");
        //PrincipalToken pt = PrincipalToken(ptAddr);

        IFactory.CurvePoolParams memory params = IFactory.CurvePoolParams({
            A: 20000000,
            gamma: 100000000000000,
            mid_fee: 5000000,
            out_fee: 45000000,
            fee_gamma: 5000000000000000,
            allowed_extra_profit: 10000000000,
            adjustment_step: 5500000000000,
            ma_exp_time: 1200,
            initial_price: 1e18
        });

        uint256 initialLiquidity = 100 * IBT_UNIT;
        underlying.mint(MOCK_ADDR_1, ibt.convertToAssets(initialLiquidity));
        vm.startPrank(MOCK_ADDR_1);
        underlying.approve(address(ibt), ibt.convertToAssets(initialLiquidity));
        ibt.deposit(ibt.convertToAssets(initialLiquidity), MOCK_ADDR_1);
        ibt.approve(address(factory), initialLiquidity);

        // High minPTShares to force depositIBT to return 0 (requires PT impl detail)
        factory.deployCurvePool(ptAddr, params, initialLiquidity, 200 * IBT_UNIT); // Assumes revert in real PT

        vm.stopPrank();
    }

    function test_UnrestrictedPTDeployment() public {
        // Create attacker address
        address attacker = address(0xDEAD);

        // Switch to attacker context
        vm.startPrank(attacker);

        // Attacker can deploy PT without authorization
        address ibtCoin = address(0x123); // Any IBT address
        uint256 duration = 30 days;
        address deployedPT = address(0xBEEF);
        deployedPT = address factoryInstance.deployPT(ibtCoin, duration);

        // Stop attacker context
        vm.stopPrank();

        // Verify PT was registered in protocol
        bool isRegistered = IRegistry(factory.getRegistry()).isRegisteredPT(deployedPT);
        assertTrue(isRegistered, "Unauthorized PT was successfully registered");

        // Attackers could flood registry with illegitimate PTs
    }


function test_DecimalMismatchVulnerability() public {
    // Assume we have IBT with 6 decimals (like USDC)
    MockToken ibt6Decimals = new MockToken("IBT-6Dec", "IBT6", 6);
    
    // Deploy PT that would normally use 18 decimals
    address pt = factory.deployPT(address(ibt6Decimals), 365 days);
    
    // Set up curve pool parameters
    CurvePoolParams memory params = CurvePoolParams({
        A: 100,
        gamma: 1e18,
        mid_fee: 0.003e18,
        out_fee: 0.003e18,
        fee_gamma: 1e18,
        allowed_extra_profit: 0,
        adjustment_step: 1e18,
        ma_exp_time: 1 days,
        initial_price: 1e18  // 1:1 intended ratio
    });
    
    // Amount for initial liquidity (with 6 decimals)
    uint256 initialLiquidity = 1000 * 10**6;
    
    // Deploy curve pool and add initial liquidity
    address curvePool = factory.deployCurvePool(pt, params, initialLiquidity, 0);
    
    // Get actual pool balances
    uint256 ibtInPool = IERC20(address(ibt6Decimals)).balanceOf(curvePool);
    uint256 ptInPool = IERC20(pt).balanceOf(curvePool);
    
    // Calculate actual price (considering decimal differences - ibt has 6, pt has 18)
    uint256 actualPrice = (ibtInPool * 10**18) / (ptInPool * 10**6);
    
    // Should be close to the intended initial price (1e18), but will be off due to decimal mismatch
    assertNotApproxEqRel(actualPrice, 1e18, 0.01e18, "Pool ratio correct despite decimal mismatch");
}

function test_UnsafeCurvePoolDeployment() public {
    // Deploy a PT
    address ibt = address(mockIBT);
    uint256 duration = 365 days;
    address pt = factory.deployPT(ibt, duration);
    
    CurvePoolParams memory params = CurvePoolParams({
        A: 100,
        gamma: 1e18,
        mid_fee: 0.003e18,
        out_fee: 0.003e18,
        fee_gamma: 1e18,
        allowed_extra_profit: 0,
        adjustment_step: 1e18,
        ma_exp_time: 1 days,
        initial_price: 1e18
    });

    // Mock the Curve Factory to return address(0)
    vm.mockCall(
        factory.getCurveFactory(),
        abi.encodeWithSelector(ICurveNGFactory.deploy_pool.selector),
        abi.encode(address(0))
    );

    // Expect event emission despite failure
    vm.expectEmit(true, true, true, true);
    emit CurvePoolDeployed(address(0), ibt, pt);
    
    // Initial liquidity amount
    uint256 initialLiquidity = 1000e18;
    
    // Execute function that would trigger the bug
    address curvePool = factory.deployCurvePool(pt, params, initialLiquidity, 0);
    
    // Factory returns and accepts the invalid address
    assertEq(curvePool, address(0), "Factory accepts an invalid pool address");
    
    // Attempts to add liquidity to address(0) would result in loss of funds
}



```
